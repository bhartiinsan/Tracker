Theory: CPU & Memory Location of Variables in Python üß†
1Ô∏è‚É£ Variables Are References, Not Boxes

In Python, a variable does not directly store a value.
Instead, it stores a reference (address) to an object in memory.


x = 10

What happens internally:

Python creates an integer object 10 in memory (RAM / heap).

The variable x stores a reference to that object, not the value itself.

So:

x ‚Üí memory address ‚Üí object(10)


---------------------------------------------------------------------------------------------------------------

2Ô∏è‚É£ Objects Live in Heap Memory

Python stores objects in the heap, a region of RAM used for dynamic allocation.

Heap ‚Üí stores objects (10, "Hello", lists, etc.)

Stack ‚Üí stores function calls & local references

Variables mostly hold references on the stack, pointing to heap objects.

----------------------------------------------------------------------------------------------------------------

3Ô∏è‚É£ Role of CPU

The CPU:

‚úÖ Executes Python bytecode
‚úÖ Reads references
‚úÖ Fetches objects from memory
‚úÖ Performs operations

When you run:

y = x + 5


CPU steps:

Fetch object referenced by x

Fetch object 5

Perform addition

Create new object 15

Store reference in y

4Ô∏è‚É£ Why id() Shows Memory Address
x = 10
print(id(x))


id() returns the identity of the object (usually its memory address in CPython).

Important:

‚úî id(x) ‚Üí address of object
‚ùå Not address of variable name

5Ô∏è‚É£ Object Reuse (Interning / Caching)

Python optimizes memory by reusing objects.

Example:

a = 10
b = 10


Both may point to the same memory location because:

Small integers (-5 to 256) are cached

Saves memory & improves speed

So:

a ‚Üí object(10)
b ‚Üí object(10)


Same object ‚úî

6Ô∏è‚É£ What Happens When Value Changes
x = 10
x = 20


Python:

Creates new object 20

Updates reference of x

Old object 10 may be garbage collected (if unused)

Variables don‚Äôt change objects ‚Äî they change reference